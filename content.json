{"meta":{"title":"CheDabang Blog","subtitle":null,"description":null,"author":"CheDabang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-02-24T03:36:44.000Z","updated":"2017-02-24T03:43:13.296Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我路茫茫其修远兮，吾将上下而求索 前端段子手–车大棒 Email：che_dabang@qq.com"},{"title":"categories","date":"2017-02-24T03:01:05.000Z","updated":"2017-02-24T03:08:39.732Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-24T02:59:17.000Z","updated":"2017-02-24T02:59:57.448Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"车大棒浅谈for循环+canvas实现黑客帝国矩形阵","slug":"170113","date":"2017-01-13T12:53:32.000Z","updated":"2017-02-24T09:11:23.155Z","comments":true,"path":"2017/01/13/170113/","link":"","permalink":"http://yoursite.com/2017/01/13/170113/","excerpt":"背景 一日在网上闲逛的之时，突然看到一个利用JQ插件实现canvas实现的电影黑客帝国的小Demo。觉得创意不错，就下载下来研究一下。","text":"背景 一日在网上闲逛的之时，突然看到一个利用JQ插件实现canvas实现的电影黑客帝国的小Demo。觉得创意不错，就下载下来研究一下。 网上浏览jQuery的写法12345678910111213141516171819202122232425262728$(document).ready(function() &#123; var s = window.screen; var width = q.width = s.width; var height = q.height; var yPositions = Array(300).join(0).split(''); var ctx = q.getContext('2d'); var draw = function() &#123; ctx.fillStyle = 'rgba(0,0,0,.05)'; ctx.fillRect(0, 0, width, height); ctx.fillStyle = 'red'; ctx.font = '10pt Georgia'; yPositions.map(function(y, index) &#123; text = String.fromCharCode(1e2 + Math.random() * 33); x = (index * 10) + 10; q.getContext('2d').fillText(text, x, y); if(y &gt; Math.random() * 1e4) &#123; yPositions[index] = 0; &#125; else &#123; yPositions[index] = y + 10; &#125; &#125;); &#125;; RunMatrix(); function RunMatrix() &#123; Game_Interval = setInterval(draw, 1000); &#125;&#125;); 全程100行不到的代码，主体的核心就是定时器调用canvas进行绘画处理。要是让我这种段子手来写，估计我把敲烂键盘都想不出这样营造效果。艺术细胞真的很重要咕~~(╯﹏╰) 老王：“等等大棒！不是说js+canvas实现黑客帝国矩形雨，可是你这个附上的代码分明是jQ+canvas.” 老管：”就是！你这个标题汪，这是又要搞事情呀！” 我：“别急呀！这个jQ+canvas因为网上很多人博客都有写，所以这边只是附上一下jQ代码供大家参考。下面才是我今天要通过for循环代替上面的map()来实现的！！ 夫子：别净扯理由，你是根本就不会map()用法！！” 老齐： “净说什么大实话！大棒是根本看不懂……” 我：………好吧！你们说对了，我的确是不会map()方法。（让我蹲墙角哭会/((╥╯^╰╥)” 万能for循环的写法好了不扯犊子了，言归正传。让我们回到下面要讲的代码上面来。 1、基本准备工作1.1、HTML骨架部分1&lt;canvas id=\"hacker\" width=\"500\" height=\"500\"&gt;请使用Google浏览器或者IE9以上&lt;/canvas&gt; 1.2、JavaScript部分1234var hacker = document.getElementById(\"hacker\");var width = hacker.width = screen.width; //screen.width拿到是当前屏幕宽度var height = hacker.height;var ctx = haceker.getContext('2d'); 做完这几步之后，我们就能够拿到当前屏幕的宽度、以及canvas画布的宽度和得到canvas画布的上下文。 2、数组的准备12var num = Math.ceil(width / 10);var y = Array(num).join(0).split(''); 这里估计有人会询问了，这里创建一个数组是干嘛。为什么数组的length &gt;= num？ O(∩_∩)O哈哈~，别着急，后面的代码就会个大家逐一解释了。 3、定义一个重复调用核心draw()方法123456789101112131415161718var draw = function() &#123; ctx.fillStyle = 'rgba(0,0,0,.05)'; //创意核心语句之一 ctx.fillRect(0, 0, width, height); ctx.fillStyle = '#0f0'; ctx.font = '10px Microsoft YaHei'; for(i = 0; i &lt; y.length; i++) &#123; var x = (i * 10) + 10; text = String.fromCharCode(1e2 + Math.random() * 33); var y1 = y[i]; ke.getContext('2d').fillText(text, x, y1); console.log(height); if(y1 &gt; Math.random() * 10 * height) &#123; y[i] = 0; &#125; else &#123; y[i] = parseInt(y[i]) + 10; &#125; &#125;&#125; 3.1、ctx绘画过程解释**12ctx.fillStyle = 'rgba(0,0,0,.05)'; //创意核心语句之一ctx.fillRect(0, 0, width, height); 这里为设定的区域铺上一个rgba(0,0,0,.05) 这样黑色半透明的背景。 12ctx.fillStyle = '#0f0';ctx.font = '10px Microsoft YaHei'; 这里就是画出大小为 10px，字体为微软雅黑的字体。 两行代码看起来就是很普通的代码，但是组合起来却发生一个质的变化。 为什么会有层次感呢？要知道getContext(‘2d’)这句语句，就决定了canvas只能绘制2D图像，不能绘制3D层次感的图形！ 答案就在 ctx.fillStyle = &#39;rgba(0,0,0,.05)&#39;;上面，当重复调用方法的时候，这种半透明的灰黑色背景就会盖在之前的画好绿色文字上面。因此因此就造成了有文字是绿色，有的文字变成灰绿色。 各个文字之间形成一种视觉差，从而让人感觉到3D立体矩形代码阵效果。所以当我发现两组这么普通的代码组合起发生如此厉害效果，当即激动拍了拍键盘。大呼一声！ “哇靠！这个真心666！” 3.2、for循环解释123456789101112for(i = 0; i &lt; num; i++) &#123; var x = (i * 10) + 10; text = String.fromCharCode(65 + Math.random() * 62); var y1 = y[i]; ctx.fillText(text, x, y1); console.log(height); if(y1 &gt; Math.random() * 10 * height) &#123; y[i] = 0; &#125; else &#123; y[i] = parseInt(y[i]) + 10; &#125; &#125; 3.3、关于canvasX轴上面文字控制**因为前面每次画的文字大小都是10px，那么如果我把canvasX轴平铺满。需要多少个文字呢。 答案 = Math.ceil(width / 10); =&gt; 即就是我前面的num 小说明： 为什么得用Math.ceil()向上取整，而不能用Math.floor向下取整，parseInt()之类。 因为假设num = 300.8样子，那么使用Math.floor() 或者parseInt(),就好把这个数转换成300 那么后面，绘制300个文字在canvasX轴，那么最右边就还有0.8个文字，也就是8px空隙一种没有字母出现。向上取整，就会铺满，多的部分超出canvas区域，就会消失。 text = String.fromCharCode(65 + Math.random() * 62);这里就是每次for循环的时候产生65 - 127 的数字，之后将其转换为大写、小写字母，以及一些符号 3.4、关于canvasY轴的控制**这里前面定义的数组就派上用场了var y = Array(num).join(0).split(&#39;&#39;);,这里就是用于记录与控制每一次canvas文字的Y轴。 为什么要用数组去记录呢？说实话，当初我也是这么认为的，所以我没有尝试控制每一个文字Y轴的数据，让所以的Y轴依次累加，结果效果如下： 所以之后我就奇思妙想，让每次文字是排列X轴平铺数字随机呈现。例如第一次平铺300个，第二次平铺100个，第三次平铺200…….,但是我还是错了： 错误的代码示范 所以多次失败的尝试之后，发现还是得控制利用一个数组控记录与控制每一个数字Y轴的数据。 代码的收尾1234 Run(); function Run() &#123; Game_Interval = setInterval(draw, 30);&#125; 之后设置一个定时器，每次间隔30ms调用一次，然后大功告成。一个炫酷的黑客帝国矩形雨效果就出来了。 当然前面JavaScript代码可能太凌乱，所以这边就把JavaScript的全部呈上： 123456789101112131415161718192021222324252627282930 window.onload = function() &#123; var kacker = document.getElementById(\"hacker\"); var width = hacker.width = screen.width; var height = kacker.height; var ctx = hacker.getContext('2d'); var num = Math.ceil(width / 10); var y = Array(num).join(0).split(''); var draw = function() &#123; ctx.fillStyle = 'rgba(0,0,0,.05)'; ctx.fillRect(0, 0, width, height); ctx.fillStyle = '#0f0'; ctx.font = '10px Microsoft YaHei'; for(i = 0; i &lt; num; i++) &#123; var x = (i * 10) + 10; text = String.fromCharCode(65 + Math.random() * 62); //console.log(text); 用来检测 text 的值 var y1 = y[i]; ctx.fillText(text, x, y1); if(y1 &gt; Math.random() * 10 * height) &#123; y[i] = 0; &#125; else &#123; y[i] = parseInt(y[i]) + 10; &#125; &#125;&#125;Run();function Run() &#123; Game_Interval = setInterval(draw, 100); &#125; &#125; 看到这里不要以为代码就此结束了，好好吸收那个for循环之后。接下来再返回上面看一下map()方法，相信map()方法的用法是不是一下子清晰明了。一箭双雕，既实现了5毛的特效，又帮助熟悉了一个map()方法用法. 效果预览：黑客帝国矩形阵（ps：效果图挂在阿里云上面，部分平台点击进去可能会有提示，例如微信，请忽略…..） 我是车大棒,深藏功与名！（滑稽脸）","categories":[{"name":"前端浅谈","slug":"前端浅谈","permalink":"http://yoursite.com/categories/前端浅谈/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"车大棒浅谈微信红包随机分配猜想","slug":"170106","date":"2017-01-06T09:16:26.000Z","updated":"2017-02-24T09:13:37.905Z","comments":true,"path":"2017/01/06/170106/","link":"","permalink":"http://yoursite.com/2017/01/06/170106/","excerpt":"背景 做为一名贫困的月光搬砖党，如果想每天加餐能够多加一块肉。那么就得靠微信红包手速抢红包，所以为了实现梦想。我给自己制定了目标，先抢够一个亿。","text":"背景 做为一名贫困的月光搬砖党，如果想每天加餐能够多加一块肉。那么就得靠微信红包手速抢红包，所以为了实现梦想。我给自己制定了目标，先抢够一个亿。 可是这几天微信红包手气，完全都不忍直视呀。每次都手气最差，就连自己的发的红包自己抢，也还是抢几分钱。阿西吧！早餐包子钱都吃不上了。 微信红包顺序拆分猜想所以当我看见隔壁老王正在吃着热腾腾的包子加豆浆，只能默默端起了水杯去饮水机旁边打水喝，打算用水安抚我抗议的胃。 之后一边静静灌水喝，一边开始思索起来。为什么老王运气好，总是能够得到最佳手气。而我却总是几分几分，这不科学。难得微信红包有什么奥秘？难得拆分红包的先后顺序会影响最佳手气的概率？ 于是本人赶紧上网搜了搜，原来早在微信红包出来的时候。就有人已经对于微信红包的随机分配算法进行探讨，并给出了相应回复。（看看大佬们都关注点总是和我们这些弱渣关注点不一样，(ˇˍˇ) 向大佬们低头。） 可是很块我就发现，这个仅供参考的代码就有一点问题。根据图中的代码 double min = 0.01； double max = _leftMoneyPackage.remainMoney / _leftMoneyPackage.remainSize * 2; 通过知乎大神上面的提供的代码可以看出，微信发放的红包中。单个红包最小金额为0.01元，而最大金额则为 剩余的金额 / 剩余未拆开红包的数量 之后再乘以2 即我发一个5毛钱的红包，分5人发送。那么其中手气最佳的最大金额应该是 5 / 5 * 2 = 2毛。对此我在微信群，发了一个5毛红包做了测试： 这里老王在专心吃的他的包子，因此没有去抢我发的红包。可是这样我还是一样拿不到手气最佳，心疼我这个手气…… 嗯额，不扯远了。通过这个手气最佳的金额来看 0.34 &gt; 0.5/5 * 2 ，因此从这个红包的金额来看，现在微信单个红包最大金额不满足知乎提供的公式。（在当时是不是满足，我就不清楚了，毕竟是好几年的公式了！） 但是后续在多个群里测试多个5毛红包之后，发现这个关于第一个领红包、以及最后一个领红包先后顺序领红包，获得手气最佳的概率是一样的。 只能说跟欧洲人和非洲人有关，看来这几天得多到老王的位置吸吸欧气 (￣_,￣ ) 其他的随机算法实现 在通过惨痛红包测试之后，证明现在当初那个公式可能有误。但是肿么不能这样就结束了，总得搞点事情出来呀！（于是乎，翻阅半天的帖子之后，便回到当初知乎题主提问的问题上，尝试解决他的问题。~(～￣▽￣)～） 回头解决知乎题目猜想：尝试了一下，题主的问题。我好像能够解决呢！！ 说实话，还是觉得题主的这个随机分配想法还是很妙的，要是我就想不出来这种随机分配金额的办法来。也要向提问题主低头(* ￣︿￣)！ 123456789101112131415161718192021222324252627282930313233function weixin1(money, num) &#123; var arr1 = []; var price = 0; var ha = 0; var random = 0; for(var i = 0; i &lt; num; i++) &#123; if(i == num - 1) &#123; arr1[i] = parseFloat(money.toFixed(2)); break; &#125; arr1[i] = parseInt(parseInt(money / (num - i) * 100) / 100 * (parseInt(Math.random() * 100) / 100) * 100) / 100; if(!arr1[i])&#123; arr1[i] = 0.01; &#125; money -= arr1[i]; console.log(money); &#125; for(var i = 0; i &lt; arr1.length; i++) &#123; //用来检测最后的总数是否正确 price += arr1[i]; &#125; function randomsort(a, b) &#123; return Math.random() &gt; 0.5 ? -1 : 1; &#125; arr1.sort(randomsort); //数组重新随机排列 console.log(arr1) console.log(price);&#125;weixin1(100, 5);weixin1(0.5, 5); 以上就是对微信红包随机分配猜想的胡扯篇，欢迎各位大佬们指导并给出相应的意见。（当然红包打赏我就更好了(￣︶￣)，哎呦！我又想起了我那么多可怜测试红包。）","categories":[{"name":"前端浅谈","slug":"前端浅谈","permalink":"http://yoursite.com/categories/前端浅谈/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"浅谈web前端自动化工具--gulp","slug":"161129","date":"2016-11-29T02:23:32.000Z","updated":"2017-02-24T07:01:25.836Z","comments":true,"path":"2016/11/29/161129/","link":"","permalink":"http://yoursite.com/2016/11/29/161129/","excerpt":"","text":"背景：在前端的开发中上线之前可能会做的事情： 1、文件目录调整HTML注释、换行等操作。2、CSS压缩合并、JS代码压缩重命名。3、CSS语法检测4.、……. 上述这些操作是重复而枯燥的，如果是人工来一项一项做，会浪费大量时间。而且人工操作有时候还会带来一些想不到的bug。例如css改动导致页面错位、js改动可能导致功能不正常。 这个时候web前端自动化工具就出现了，当然前端的飞速发展。各种web前端自动化工具也层出不穷，这里就浅谈一下我个人用的web前端自动化工具–gulp。 准备工作1.1、 打开nodejs官网，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。然后像安装QQ一样安装它就可以了（安装路径随意）。因为在安装并使用gulp的时候，需要先安装node.js.利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 1.2、 安装好了之后，打开cmd命令行输入node -v，用来检测是否安装成功。如安装成功则提示node.js的版本号。 1.3 、 由于nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 npm -v 来测试是否成功安装。同上述node.js方法一样，安装成功则提示npm的版本号。 gulp全局安装2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；2.2、安装：命令提示符执行npm install gulp -g；2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。 新建一个package.json文件3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；3.2、以我个人的一个项目当中的一个json文件为例 3.3、当然如果说手动配置这些东西，那么今天的主题估计就不能够称为web前端自动化了。这里我们通过CMD命令符执行npm init 3.4、为了方便读者更好了解这个 npm init 的使用，我讲自己原本的package文件删除。重新执行npm init 安装gulp 本地服务4.1、进入该项目目录下，输入npm install gulp-less –save-dev4.2、 这个时候可能有人会问，为什么前面全局下安装了一个gulp，现在又在本地文件下还要安装gulp。我们全局安装了gulp，项目也安装了gulp。为啥装两遍？？说明：全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能，作为项目的开发依赖（devDependencies）。4.3、之后继续安装gulp插件。本示例以gulp-rename（文件重命名）和gulp-uglify（js代码压缩）为例，命令提示符分别执行npm install gulp-rename –save-dev 和 npm install gulp-uglify –save-dev .4.4、CMD指令执行完毕之后，这个时候你的当前目录下，就生成了node_modules文件夹。 新建gulpfile.js文件（重要）gulpfile.js这个入口文件，在前面已经出现了不少次数了。下面就开始关于gulpfile.js文件配置，还是以本人的项目代码为例： gulp运行6.1、进入gulpfile文件下打开CMD，输入gulp dabang 6.2、运行成功之后，最后我的文件夹当中出现一个js代码压缩，后缀名添加min的js文件。 小结7.1、安装nodejs；7.2、gulp全局安装npm install gulp -g7.3、项目文件安装本地gulp服务 npm install gulp-less –save-dev以及相应的gulp 插件7.4、新建package.json文件；7.5、新建gulpfile.js文件；7.6、通过命令提示符运行gulp任务 以上就是关于web前端自动工具–gulp个人的简单一点的使用，更多gulp 插件以及API使用，请访问请查看 gulp中文网. 注：以上就是个人对于gulp使用的一点心得，欢迎各位大佬(￣ε(#￣)打脸指教！！","categories":[{"name":"前端浅谈","slug":"前端浅谈","permalink":"http://yoursite.com/categories/前端浅谈/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/tags/前端工具/"}]},{"title":"Hexo初见博客","slug":"hexo","date":"2016-07-22T07:08:32.000Z","updated":"2017-02-22T12:28:43.727Z","comments":true,"path":"2016/07/22/hexo/","link":"","permalink":"http://yoursite.com/2016/07/22/hexo/","excerpt":"","text":"关于Hexo的初次体验语法","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"车大棒浅谈清除浮动塌陷的4种经典套路","slug":"160709","date":"2016-07-09T14:25:31.000Z","updated":"2017-02-24T07:29:51.230Z","comments":true,"path":"2016/07/09/160709/","link":"","permalink":"http://yoursite.com/2016/07/09/160709/","excerpt":"前言“自古深情留不住，总是套路得人心。”这些日子，各个朋友圈随时可以见到这句话的身影。的确人们常说：“多一点真诚，少一点套路。”，但是最终现象写实也是那么残酷和无奈。同样在前端攻城狮的道路，我们都是真诚尽心尽力的去学习进取。奈何昔日各大浏览器厂商的大战不断，导致我们这群学习的人苦不堪言，一片水生火热呀。不得不想进各种hack方法解决。（没错，这里就是吐槽的IE6！）","text":"前言“自古深情留不住，总是套路得人心。”这些日子，各个朋友圈随时可以见到这句话的身影。的确人们常说：“多一点真诚，少一点套路。”，但是最终现象写实也是那么残酷和无奈。同样在前端攻城狮的道路，我们都是真诚尽心尽力的去学习进取。奈何昔日各大浏览器厂商的大战不断，导致我们这群学习的人苦不堪言，一片水生火热呀。不得不想进各种hack方法解决。（没错，这里就是吐槽的IE6！） 其次文档标准流，在浮动之后也会挖下塌陷的大坑。初学者稍有不慎，塌陷的失控的子元素到处乱窜，弄的你鸡飞狗跳苦不堪言。那么为了后面前端大道越行越远，下面就跟大家讲解一下清除浮动的4种套路。不过在讲套路得时候，咱们顺带的也把浮动之后塌陷大坑给顺便重现一样。 浮动塌陷大坑：先来看一个小小的demo：现在有两个div，div身上没有任何属性。每个div中都有li，这些li都是浮动的先是html骨架部分 下面的是css样式： 看到这里，如果说没有吃过浮动塌陷大亏的同学，肯定会以为这个网页中效果是这个样子 但是实际上浏览器最终的渲染的样子： 第二个div中的li，去贴第一个div中最后一个li的边了。原因就是因为div没有高度，不能给自己浮动的孩子们，一个容器。所以第二个div中的li，去贴第一个div中最后一个li的边了！这种现象又称作为浮动塌陷现象！ 套路讲解讲完浮动塌陷之后，让我开始回归今天的正题。清除浮动塌陷的4种套路方法 套路1：给浮动的元素的上级添加高度如果一个元素要浮动，那么它的祖先元素一定要有高度。高度的盒子，才能关住浮动。只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。所以只需要给li的上级ul或者div设置一个height：40px；（只要是浮动元素的上级元素就可以。），那么第二个div就好挤下来，在第一个盒子下面显示出来。 套路2：clear:both;但是在实际开发过程当中中，高度height很少出现。为什么？因为能被内容撑高！那也就是说，刚才我们讲解的方法1，工作中用的很少。那么这里有人可会脑洞大开：能不能不写height，也把浮动清除了呢？也让浮动之间，互不影响呢？事实上的确有这样的解决方法，是给他的上级添加一个clear：both；首先Clear就是清除的意思，both，代表左浮动和右浮动都清除掉。通俗一点来讲，就是说清除别人对我的影响。 虽然说这样可以清除浮动塌陷现象，但是同样也会有一个致命的问题。那就是两个div之间，margin值失效了，无法设置。再重申一下，是指两个div之间。 套路3：隔墙法既然用clear：both会导致两个div之间margin失效，那么到后面有人又开始脑洞大开了。在中间一个空盒子，然后给那个空盒子clear：both；（为了方便大家看效果，这里并没有放的是空盒子，而是放的有一个有高度、有颜色的盒子。） 这样加了一堵墙之后，第二个div就能掉下来并且不干扰了上面的元素。而且第二个div还是能通过magin-top调节两个div（“墙体”div不要算进去）之间的间距，所以隔墙法作为一个新的套路沿传开来。 套路3.1：隔墙法进化版—内墙法在这个世界上面存在一种人–完美主义者，在他们的世界观里面瑕疵是坚决不允许的。然后在前端行业中，也有一批追求完美主义前端攻城狮。他们对于隔墙法的小瑕疵表示完全不能接受，所以这一群完美主义的前端攻城狮开始对他的隔墙法的完美的改造进化去了。于是“内墙法”横空诞生，先来看一下代码结构： 只是将墙体的位置改变了，就完美的解决第一个div不能通过margin-bottm来调节与下面div之间的间距。所以后面很长一段时间，“内墙法”成为各大公司清除浮动主流写法。 套路4：overflow：hidden；overflow就是“溢出”的意思，hidden就是“隐藏”的意思。内容太多，溢出了盒子 overflow:hidden;溢出盒子边框的内容，隐藏了。 这个样式本意就是清除溢出到盒子外面的文字。但是，某些前端攻城狮工程师又发现了，它能做偏方。写法简单粗暴，好理解。属于在W3C文档额外扩展，就好比发明摩托车的人绝对不会想到，后面摩托车特技能够把摩托头扬起来行驶。所以这个overflow：hidden；也算是一个“祖传老偏方”，能治浮动塌陷老毛病。当然既然是“偏方”，肯定就有因为有些特殊情况下不能解决。导致只是沦为“偏方”上不正统。特殊情况就是定位的时候，若定位的区域超出那个盒子，overflow：hidden；就会把多的部分裁切掉。所以除了这个老毛病，overflow：hidden；其简单粗暴的写法，还是有与“内墙法”一争正室能力。 总结其实还有很多套路能够清除浮动，比如给浮动塌陷的元素再添加一个浮动，添加一个绝对定位……等一些方法。但是添加浮动，那样只是把塌陷对象的层级上移了而已，给塌陷对象添加绝对定位同样，也会受到其他定位的区域影响。所以这些消除定位之外，还需要额外添置的别的样式的套路因此不在我们关注的范围当中。咱们只讲这4种前端开发过程主流清除浮动塌陷的套路，听完这四种套路之后，以后各位小伙伴将采用哪一种方式清除浮动呢！估计很多小伙伴会使用“内墙法”来清除浮动的，的确内墙法以前是很流行。但是随着时代是不断进步的，很多企业在实际开发过程当中不再单纯的使用了“内墙法”这里估计有人就会吐槽了，不是说好了主流清除浮动就4种套路吗？这4种套路就目前就“内墙法”没有暴露问题，难不成用冷门的？别着急，现在企业里面采用的清除浮动方法综合法，又名内墙法2.0给浮动塌陷的盒子添加一个：after伪类 这种方法在各个大型项目上都有出现过，可谓清除浮动的万金油呀！本来说好的四种套路，现在除了那四种套路之外却一下子延伸出好几种清除浮动的套路，估计有些小伙伴要晕了吧。下面让我们通过思维导图来帮助，晕头的小伙们整理思路吧！ 之所以给各位小伙伴绕了这么大一个圈子。就是怕直接就把这种方法拿出来告诉大家。肯定会有小伙伴疑惑为什么要这么写，而此时看到相信各位看完本文的套路介绍之后，对清除的浮动的方法有了更深刻的了解了吧。我是车大棒，我的目标是星辰与大海。","categories":[{"name":"前端浅谈","slug":"前端浅谈","permalink":"http://yoursite.com/categories/前端浅谈/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"清除浮动","slug":"清除浮动","permalink":"http://yoursite.com/tags/清除浮动/"}]}]}